# iOS developer interview questions

## Language: Swift & Objective-C (частично)

### Какие преймущества у Swift-a? 
Swift был выпущен в 2014 году и имеет ряд преймуществ:
- Безопасный за счет строгой типизации
- Приятный синтаксис, который легче воспринимается (в сравнении Objective-C)
- Объединен с управлением памятью (ARC)
- Наличие функциональных парадигм
- Наличие дженериков (Generic)
- Наличие кортежей (Tuple)
- Наличие опциональных значений (Optional)

### Какими способами можно проверить условие(я)? Когда лучше использовать каждый из них?
1. Использовать `if` или `if-else`, когда нужно проверить одиночное условие или ряд связанных между собой условий 
```swift
let value: Int = 100

if value <= 0 {
  // Значение `value` меньше или равно нулю
} else if value > 0 && value < 1000 {
  // Значение `value` больше нуля и меньше тысячи
} else {
  // Значение `value` больше тысячи или равно
}
```
2. Использовать `switch`, когда нужно проверить свойство на несколько значений
```swift
let state: SomeState = .visible

switch state {
case .visible:
  // Текущее состояние `visible`
case .hidden:
  // Текущее состояние `hidden`
}
```

### Как использовать тернарные операторы? В каких случаях они лучше чем условия?
``` swift
let value: Int = 150
// Тернарные операторы лучше использовать для определения значения для свойства
let badgeValue: Int = value > 99 ? 99 : value
```

### Какими способами можно запустить цикл? Когда лучше использовать каждый из них?
1. Использовать `for-in` в случаях когда нужно перебрать определенную коллекцию, но при выполнении определенного условия прекратить этот цикл
```swift
let names: [String] = ["Иван", "Тарас", "Андрей"]
for name in names {
  guard name == "Тарас" else {
    // Достигли другого имени, продолжаем цикл
    continue
  }
  // Достигли имени "Тарас" и прекращаем цикл
  break
}
```
2. Использовать `for-each` в случаях, когда нужно перебрать всю коллекцию
```swift
let names: [String] = ["Иван", "Тарас", "Андрей"]
names.forEach { (name) in
  guard name == "Иван" else {
    // Достигли другого имени, продолжаем цикл
    return
  }
  // Достигли имени "Иван", но цикл продолжается
}
```
3. Использовать `while` когда нужно перебрать не связанные коллекцией между собой свойства и достигнуть определенного значения
```swift
// Мы берем определенный `UIViewConroller`
var topViewController = self.window.rootViewController
// Далее начинаем проверять поочередно каждый `presentedViewController`
while topViewController?.presentedViewController != nil {
  topViewController = topViewController?.presentedViewController
}
// Мы достигнем крайнего `presentedViewController`
return topViewController
```

#### Чем отличается `for-in` от `for-each`?
`for-in` можно остановить на одной из итераций, в то время когда `for-each` обязательно пройдет по всей колекции

#### Чем отличается `return`, `break` и `continue`?
`return` - прекращает текущий RunLoop
`break` - прекращает текущий цикл
`continue` - прекращает текущую итерацию цикла

### Что такое опциональное значение (Optional)? Как они реализованы?
Это необязательные параметры. Они реализованы как enum, который может хранить нулевое значение с кейсами `.none` и `.some`. Когда он сохраняет значение, он оборачивается вокруг значения. Чтобы получить значение, заключенное в необязательный параметр, вам необходимо его развернуть.

#### Какие существуют способы чтобы развернуть опциональное значение? Какие преймущества у каждого из них?
1. Используйте `if-let` когда нужно безопасно получить опциональное значение. Лучше всего использовать, когда развернутое значение не обязательно, но может влиять на результат. Например: если у нас есть пользователь, то мы отобразим его имя, в противном случае не отобразится ничего
```swift
let user: User?
// 1. Используйте `if-let` когда нужно безопасно получить опциональное значение. Лучше всего использовать, когда развернутое значение не обязательно, но может влиять на результат. Например: если у нас есть пользователь, то мы отобразим его имя, в противном случае не отобразится ничего
if let safeUnwrappedUser = user {
  // Значение `safeUnwrappedUser` безопасно развернуто и его можно использовать
}
```
2. Используйте `guard-let`когда нужно безопасно получить опциональное значение. Изначально кажется что разницы между `if-let` и `guard-let` нету, но это не так. В данном случае обязательно нужно прервать текущий `RunLoop`. Такой вариант лучше использовать если проверка обязательная, чтобы не создавать пирамиду из `if-let`. Например: данные пользователя нужны для отправки запроса
```swift
let user: User?
guard let safeUnwrappedUser = user else {
  // Значение `user == nil` и не удалось развернуть
  return
}
// Значение `safeUnwrappedUser` безопасно развернуто и его можно использовать
```
3. Используйте `forced unwrapping` только в тех случаях, когда вы уверены что значение присутствует. Не рекомендуеться использовать
```swift
var user: User?
user = User(name: "Иван")
user!.name // Вернет "Иван"

var owner: User?
owner!.name // Приложение прекратит выполнение потому что `owner == nil`
```

#### Могут ли объекты быть nil в Objective-С и Swift?
В Objective-С любой объект может быть нулевым. В Swift только опциональные значения могут быть нулевыми

#### Какая разница между String! и String?
Когда мы определяем необязательный параметр implicitly unwrapped (!), мы определяем контейнер, который будет автоматически выполнять принудительное развертывание каждый раз, когда мы его читаем. В итоге мы получаем не Optional String, а обычную String, потому что текст автоматически разворачивает его содержимое. Однако текст по-прежнему необязателен, поэтому мы можем поместить в него значение nil. Но как только мы его прочитаем (а он содержит nil), мы получим фатальную ошибку, потому что мы разворачиваем необязательный, содержащий nil

#### Как использовать оператор объединения? В каких случаях лучше использовать его чем стандартный вариант чтобы развернуть опциональное значение?
``` swift
let customUser: User?
// Оператор объединения помогает получить развернутое значение из опционального и стандартного значения
let user = customUser ?? User(name: "Аноним")
```
