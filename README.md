# iOS developer interview questions

## Language: Swift & Objective-C (частично)

### Какие преймущества у Swift-a? 
Swift был выпущен в 2014 году и имеет ряд преймуществ:
- Современный и приятный синтаксис, который легче воспринимается (в сравнении Objective-C)
- Безопасный за счет строгой типизации
- Наличие опциональных значений (Optional)
- Наличие функциональных парадигм
- Наличие кортежей (Tuple)
- Наличие дженериков (Generic)
- Объединен с управлением памятью (ARC)

### Какими способами можно проверить условие(я)? Когда лучше использовать каждый из них?
1. Использовать `if` или `if-else`, когда нужно проверить одиночное условие или ряд связанных между собой условий 
```swift
let value: Int = 100

if value <= 0 {
  // Значение `value` меньше или равно нулю
} else if value > 0 && value < 1000 {
  // Значение `value` больше нуля и меньше тысячи
} else {
  // Значение `value` больше тысячи или равно
}
```
2. Использовать `switch`, когда нужно проверить свойство на несколько значений
```swift
let state: SomeState = .visible

switch state {
case .visible:
  // Текущее состояние `visible`
case .hidden:
  // Текущее состояние `hidden`
}
```

### Как использовать тернарные операторы? В каких случаях они лучше чем условия?
``` swift
let value: Int = 150
// Тернарные операторы лучше использовать для определения значения для свойства
let badgeValue: Int = value > 99 ? 99 : value
```

### Какими способами можно запустить цикл? Когда лучше использовать каждый из них?
1. Использовать `for-in` в случаях когда нужно перебрать определенную коллекцию, но при выполнении определенного условия прекратить этот цикл
```swift
let names: [String] = ["Иван", "Тарас", "Андрей"]
for name in names {
  guard name == "Тарас" else {
    // Достигли другого имени, продолжаем цикл
    continue
  }
  // Достигли имени "Тарас" и прекращаем цикл
  break
}
```
2. Использовать `for-each` в случаях, когда нужно перебрать всю коллекцию
```swift
let names: [String] = ["Иван", "Тарас", "Андрей"]
names.forEach { (name) in
  guard name == "Иван" else {
    // Достигли другого имени, продолжаем цикл
    return
  }
  // Достигли имени "Иван", но цикл продолжается
}
```
3. Использовать `while` когда нужно перебрать не связанные коллекцией между собой свойства и достигнуть определенного значения
```swift
// Мы берем определенный `UIViewConroller`
var topViewController = self.window.rootViewController
// Далее начинаем проверять поочередно каждый `presentedViewController`
while topViewController?.presentedViewController != nil {
  topViewController = topViewController?.presentedViewController
}
// Мы достигнем крайнего `presentedViewController`
return topViewController
```

#### Чем отличается `for-in` от `for-each`?
`for-in` можно остановить на одной из итераций, в то время когда `for-each` обязательно пройдет по всей колекции

#### Чем отличается `return`, `break` и `continue`?
`return` - прекращает текущий RunLoop
`break` - прекращает текущий цикл
`continue` - прекращает текущую итерацию цикла

### Что такое функциональные парадигмы? Какие виды вы знаете? Приведите пример использования
1. Используйте `map` для опциональных значений, когда для инициализации мы не можем передать опциональное значение
```swift
let array: [String]? = ["hi", "hello"]
let setFromInit: Set<String>? = Set(array) // Value of optional type '[String]?' must be unwrapped to a value of type '[String]'
let setFromMap: Set<String>? = array.map { Set($0) } // Мы конвертировали значение в другой тип без дополнительных развертываний
```
2. Используйте `flatMap` для опциональных значений, так же как и `map` за исключением случаев, когда после инициализации получаем опциональное значение. Этот вариант позволит избавиться от двойного опционального значения (`Optional<Optional<Some>>)
```swift
let string: String? = "10"
let intMap: Int?? = string.map { Int($0) }
let intFlatMap: Int? = string.flatMap { Int($0) }
```
3. Используйте `map` для колекций чтобы конвертировать значение в значение другого типа. Например из массива объектов `User` получить массив `String`
```swift
let users: [User] = ...
let userNames: [String] = users.map { $0.name }
```
4. Используйте `compactMap` в аналогичных ситуациях как `map`, но дополнительно развертываете объекты. Используется для колекций с опциональными значениями или инициализациями. Если в замыкании вернется `nil`, то объект не будет добавлен к результату, но елемент колекции будет развернутым
```swift
let users: [User?] = [
    User(name: "Иван"),
    nil,
    User(name: "Тарас")
]
let userNamesMap: [String?] = users.map { $0?.name } // [Optional("Иван"), nil, Optional("Тарас")]
let userNamesCompactMap: [String] = users.compactMap { $0?.name } // ["Иван", "Тарас"]
```
5. Используйте `filter`
6. Используйте `sort`
7. Используйте `reduce` для подсчета общего значения из коллекции
```swift
let counts: [Int] = [3, 5, 10, 32, 17, 4]
let totalCount = counts.reduce(0) { $0 + $1 } // 71
```

### Как реализованы коллекции (collections) в Swift? Какие основные типы коллекций вы знаете?
Все коллекции в Swift реализованы как Generic коллекции. В Swift предоставлены три основных типа коллекций: 
1. Array - это упорядоченные наборы значений.
2. Set - это неупорядоченные коллекции уникальных значений.
3. Dictionary - это неупорядоченные коллекции ассоциаций "ключ-значение".

#### Что быстрее? Array или Set?
Set быстрее, потому что в коллекции есть только один уникальный объект. Вы можете напрямую искать значение в наборе, но вам придется перебирать значения в массиве.

#### В чем разница между NSArray и Array? Что лучше использовать?
Array - это структура, поэтому в Swift это тип значения. NSArray - это неизменяемый класс Objective-C, поэтому он является ссылочным типом в Swift и связан с Array <AnyObject>.

#### В чем разница между NSArray и NSMutableArray (Objective-C)?
NSArray используется, когда вы не хотите изменять размер или данные, хранящиеся в массиве. В массиве NSMutableArray вы можете добавлять, удалять или изменять значения в массиве. NSMutableArray не потокобезопасный в сравнении с NSArray

#### Что такое Subscripts? Приведите примеры.
Subscripts - это индексы-ярлыки для доступа к элементам-членам коллекции.
```swift
let array: [String] = ...
let arraySubscript = array[6]

let dictionary: [String: Int] = ...
let dictionarySubscript = dictionary["key"]
```

#### Как использовать настраиваемый тип класса в качестве ключа в словаре в Swift?
Любой настраиваемый тип, для которого вы хотите использовать ключ словаря, должен соответствовать протоколу Hashable.
```swift
struct User: Hashable {
    let name: String
}
// Мы модем использовать экземпляр класса `User` как ключ словаря после того как мы имплементировали `Hashable` протокол
let dictionary: [User : Any] = [:]
```

### Что такое опциональное значение (Optional)? Как они реализованы?
Это необязательные параметры. Они реализованы как enum, который может хранить нулевое значение с кейсами `.none` и `.some`. Когда он сохраняет значение, он оборачивается вокруг значения. Чтобы получить значение, заключенное в необязательный параметр, вам необходимо его развернуть.

#### Какие существуют способы чтобы развернуть опциональное значение? Какие преймущества у каждого из них?
1. Используйте `if-let` когда нужно безопасно получить опциональное значение. Лучше всего использовать, когда развернутое значение не обязательно, но может влиять на результат. Например: если у нас есть пользователь, то мы отобразим его имя, в противном случае не отобразится ничего
```swift
let user: User?
// 1. Используйте `if-let` когда нужно безопасно получить опциональное значение. Лучше всего использовать, когда развернутое значение не обязательно, но может влиять на результат. Например: если у нас есть пользователь, то мы отобразим его имя, в противном случае не отобразится ничего
if let safeUnwrappedUser = user {
  // Значение `safeUnwrappedUser` безопасно развернуто и его можно использовать
}
```
2. Используйте `guard-let`когда нужно безопасно получить опциональное значение. Изначально кажется что разницы между `if-let` и `guard-let` нету, но это не так. В данном случае обязательно нужно прервать текущий `RunLoop`. Такой вариант лучше использовать если проверка обязательная, чтобы не создавать пирамиду из `if-let`. Например: данные пользователя нужны для отправки запроса
```swift
let user: User?
guard let safeUnwrappedUser = user else {
  // Значение `user == nil` и не удалось развернуть
  return
}
// Значение `safeUnwrappedUser` безопасно развернуто и его можно использовать
```
3. Используйте `forced unwrapping` только в тех случаях, когда вы уверены что значение присутствует. Не рекомендуеться использовать
```swift
var user: User?
user = User(name: "Иван")
user!.name // Вернет "Иван"

var owner: User?
owner!.name // Приложение прекратит выполнение потому что `owner == nil`
```

#### Могут ли объекты быть nil в Objective-С и Swift?
В Objective-С любой объект может быть нулевым. В Swift только опциональные значения могут быть нулевыми

#### Какая разница между `String!` и `String?`?
Когда мы определяем необязательный параметр implicitly unwrapped (!), мы определяем контейнер, который будет автоматически выполнять принудительное развертывание каждый раз, когда мы его читаем. В итоге мы получаем не Optional String, а обычную String, потому что текст автоматически разворачивает его содержимое. Однако текст по-прежнему необязателен, поэтому мы можем поместить в него значение nil. Но как только мы его прочитаем (а он содержит nil), мы получим фатальную ошибку, потому что мы разворачиваем необязательный, содержащий nil

### Как использовать оператор объединения? В каких случаях лучше использовать его чем стандартный вариант чтобы развернуть опциональное значение?
``` swift
let customUser: User?
// Оператор объединения помогает получить развернутое значение из опционального и стандартного значения
let user = customUser ?? User(name: "Аноним")
```

### Что такое кортежи (Tuple)?
Кортежи являются типами значений, они похожи на структуру, но способ объявления и чтения отличается. Они полезны, когда вы хотите иметь несколько типов возврата.
```swift
let user: User = ...
let userNameAndAge: (name: String, age: Int) = (user.name, user.age)
```

### Что такое универсальные шаблоны (Generic)? Приведите пример
Тип, который может принимать любой тип. Он безопасен по типу, что означает, что компилятор будет жаловаться во время компиляции. Например, если вы передадите строку как универсальный тип и используете ее как целое число, возникнет ошибка времени компиляции. Это хорошо, потому что вы можете заранее обнаружить ошибки.
В iOS SDK присутствует много примеров, которые часто используются, например: `Array<Element>`, `Optional<Wrapped>` и многие другие

#### В чем разница между AnyObject и Generic?
AnyObject не указывает какой-либо тип, поэтому он позволит вам передать любой тип, что может привести к ошибке времени выполнения. Когда вы используете дженерики, вам нужно указать определенный тип, поэтому он не позволит вам пройти, если вы введете неправильный тип во время компиляции.

#### В чем разница между associatedType и Generic?
`associatedType` используется только для протоколов, `generic` может использоваться для методов, перечислений, структур и классов
