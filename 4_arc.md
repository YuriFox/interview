# Управление памятью (memory management)

## Как работает управление памятью в Swift?
В Swift управление памяти осуществляется при помощи автоматического подсчета ссылок (automatic reference counting), который называется ARC. Он выполняет большую часть работы по управлению памятью:
- отслеживает экземпляры класса, на которые в настоящее время ссылаются (счетчик ссылок)
- освобождает пространство памяти, используемое экземплярами, на которые больше нет сильных ссылок.
- выделяет память при инициализации или деинициализации классов.

### Какой принцип работы ARC? Приведите пример.
По умолчанию каждая ссылка, указывающая на экземпляр класса, является так называемой сильной ссылкой. Пока есть хотя бы одна сильная ссылка, указывающая на экземпляр, этот экземпляр не будет освобожден. Когда не останется сильной ссылки, указывающей на этот экземпляр, экземпляр будет освобожден.
```swift
class User: NSObject {
    let name: String
    
    init(name: String) {
        self.name = name
        print("Пользователь `\(name)` инициализирован")
    }
    
    deinit {
        print("Пользователь `\(self.name)` деинициализирован")
    }
}

var user: User? = User(name: "Иван") // Пользователь `Иван` инициализирован
var userReference_1: User? = user
user = nil
userReference_1 = nil // Пользователь `Иван` деинициализирован так как все сильные ссылки на этот объект удалены
```

### Какие методы увеличивают счетчик удержания ARC на 1 (strong reference)?
- alloc / init: создает объект и заявляет права собственности на него
- retain: используется для утверждения права собственности на этот объект
- copy: Копирует объект и заявляет о праве собственности на него

### Какие методы используются для уменьшения счетчика удержаний ARC на 1?
- release: Отказаться от права собственности на объект.
- autorelease: Отказаться о праве собственности на объект.

## Чем отличаются сильные (strong), слабые (weak) и бесхозные (unowned) ссылки на объект?
1. Сильные ссылки поддерживают объект в живых, но могут привести к нескольким нетривиальным проблемам:
- Цикл ссылок (retain cycle). Swift не собирает циклы, ссылка "R" на объект, который содержит сильную ссылку на объект "R" (возможно, косвенно), приводит к циклу ссылок.
- Не всегда возможно сделать сильные ссылки действительными сразу при создании объекта, например с делегатами.
2. Слабые ссылки решают проблему обратных ссылок. Объект может быть уничтожен, если на него указывают слабые ссылки. Слабая ссылка возвращает nil, когда объект, на который она указывает, больше не жива.
3. Бесхозные ссылки - это разные виды слабых ссылок, предназначенные для инвариантов жесткой достоверности. Необнуляемые ссылки не обнуляются. При попытке прочитать несуществующий объект по неизвестной ссылке программа выйдет из строя с ошибкой утверждения. Они полезны для отслеживания и исправления ошибок согласованности.

### Что такое боковые столы (side tables)?
Это механизм для реализации слабых ссылок Swift. Обычно у объектов нет слабых ссылок, поэтому резервировать место для подсчета слабых ссылок в каждом объекте нецелесообразно. Эта информация хранится извне в дополнительных таблицах, поэтому ее можно использовать только тогда, когда это действительно необходимо.

Вместо того, чтобы прямо указывать на объект, слабые ориентиры указывают на боковой стол, который, в свою очередь, указывает на объект. Это решает две проблемы:
- экономит память для слабого счетчика ссылок, пока объект действительно не понадобится;
- позволяет безопасно обнулить слабую ссылку, поскольку она не указывает напрямую на объект и больше не является предметом условий гонки.

### Жизненный цикл объекта в Swift
Объекты Swift имеют собственный жизненный цикл.
1. `Активный (live)`. Объект жив, его счетчики ссылок инициализируются на 1 сильный, 1 безымянный и 1 слабый (боковая таблица начинается с +1). Сильный и незарегистрированный доступ к ссылкам работает нормально. При наличии слабой ссылки на объект создается боковая таблица. Слабый ориентир указывает на боковой столик вместо объекта.
2. `Деиницирования (deiniting)`. Из активного состояния объект переходит в это состояние, когда счетчик сильных ссылок достигает нуля. Это состояние означает, что `deinit()` еще не выполнился, но сильные ссылки не действуют. Из этого состояния объект может пройти по двум маршрутам:
- Если отсутствуют слабые и бесхозные ссылки, то объект переходит в `мертвое (dead)` состояние и сразу удаляется из памяти.
- В противном случае объект переходит в `деинициализированное (deinit)` состояние.
3.


Слабая ссылка читает return nil, если есть связанная побочная таблица (в противном случае нет слабых ссылок). Unowned считывает ошибку утверждения триггера. Новые бесхозные ссылки все еще могут быть сохранены. 



В деинитированном состоянии функция deinit () завершена, и у объекта есть невыполненные неопубликованные ссылки (по крайней мере, начальная +1). На этом этапе не может быть сильных и слабых запоминаний и чтений. Бесхозных магазинов тоже не может быть. Unowned читает ошибку утверждения триггера. Отсюда объект может идти двумя маршрутами:

В случае отсутствия слабых ссылок объект может быть немедленно освобожден. Он переходит в мертвое состояние.
В противном случае необходимо удалить боковой стол и объект перейдет в освобожденное состояние.
В освобожденном состоянии объект полностью освобожден, но его вспомогательная таблица все еще жива. На этом этапе счетчик слабых ссылок достигает нуля, и боковой стол уничтожается. Объект переходит в свое конечное состояние.

В мертвом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на HeapObject освобождается из кучи, не оставляя следов объекта в памяти.


Что такое утечка памяти? Как от нее избавится? Strong, Weak, Unowned
Можно ли отследить за утечкой памяти?
