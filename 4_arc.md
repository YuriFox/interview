# Управление памятью (memory management)

## Как работает управление памятью в Swift?
В Swift управление памяти осуществляется при помощи автоматического подсчета ссылок (automatic reference counting), который называется ARC. Он выполняет большую часть работы по управлению памятью:
- отслеживает экземпляры класса, на которые в настоящее время ссылаются (счетчик ссылок)
- освобождает пространство памяти, используемое экземплярами, на которые больше нет сильных ссылок.
- выделяет память при инициализации или деинициализации классов.

### Что такое cборщик мусора (garbage collector)? Как он работает в Swift?
Это техника, которая используется для управления памятью в платформах, где есть среда выполнения (.NET и Java). GC работает в рантайме CLR (Common Language Runtime). Механизм работает в фоне в самой среде исполнения и обнаруживает неиспользуемые объекты. Сборщик живет своей жизнью. Он начинает работу в недетерминированные интервалы времени. Инициировать его работу может множество факторов, например прошло некоторое количество времени, или CLR заметила, что кончается память. И в этот момент среда исполнения и сборщик мусора принимают решение, что пора освободить неиспользуемые объекты из памяти.

В Swift нету сборщика мусора. На его замену используется ARC.

### Какой принцип работы ARC? Приведите пример.
По умолчанию каждая ссылка, указывающая на экземпляр класса, является так называемой сильной ссылкой. Пока есть хотя бы одна сильная ссылка, указывающая на экземпляр, этот экземпляр не будет освобожден. Когда не останется сильной ссылки, указывающей на этот экземпляр, экземпляр будет освобожден.
```swift
class User: NSObject {
    let name: String
    
    init(name: String) {
        self.name = name
        print("Пользователь `\(name)` инициализирован")
    }
    
    deinit {
        print("Пользователь `\(self.name)` деинициализирован")
    }
}

var user: User? = User(name: "Иван") // Пользователь `Иван` инициализирован
var userReference_1: User? = user
user = nil
userReference_1 = nil // Пользователь `Иван` деинициализирован так как все сильные ссылки на этот объект удалены
```
## Какие виды атрибутов доступности свойств вы знаете?
- `readonly` - указывает, что свойство доступно на чтение и на запись, то есть будут сгенерированы и сеттер, и геттер. Это значение задается всем свойствам по умолчанию, если не задано другое значение.
- `readwrite` - указывает, что свойство доступно только для чтения. Это значение стоит применять в случаях, когда изменение свойства «снаружи» во время выполнения объектом своей задачи нежелательно, либо когда значение свойства не хранится ни в какой переменной, а генерируется исходя из значений других свойств. Например, есть у объекта User свойства firstName и lastName, и для удобства заданное readonly свойство fullName, значение которого генерируется исходя из значений первых двух свойств.

## Какие виды атрибутов атомарности (atomicity) свойств вы знаете? В чем разница атомарный (atomic) и не атомарный (nonatomic)?
- `Атомарные (atomic)` свойства обеспечивают надежный доступ к ним в многопоточной среде - то есть значение, возвращаемое из геттера или устанавливаемое через сеттер, всегда полностью извлекается или устанавливается независимо от того, какие другие потоки выполняются одновременно. Значительно медленнее. В Objective-C устанавливается по умолчанию.
- `Не атомарные (nonatomic)` свойства быстрее, но не потокобезопасны. Что может привести к неожиданному поведению, когда два разных процесса одновременно обращаются к одной и той же переменной.

В Swift по умолчанию используется nonatomic и отсутствует atomic.

## Какие виды атрибутов владения свойст вы знаете?
- `retain` / `strong` — показывает, что в сгенерированном сеттере, счетчик ссылок на присваиваемый объект будет увеличен, а у объекта, на который свойство ссылалось до этого, — счетчик ссылок будет уменьшен. При включенном ARC используется strong, а при MRC используется retain. В Swift атрибут по умолчанию;
- `copy` — означает, что мы копируем значение объекта при его создании. Также показывает, что полученное значение свойства будет иммутабельным, попытка изменения приведёт к крэшу;
- `assign` — просто присвоение адреса. С выключенным ARC является дефолтным значением в Objective-C. Стоит применять к свойствам типов, не попадающих под действие ARC (примитивные типы, тип значение);
- `unsafe_unretained` — свойство с таким типом владения просто сохраняет адрес присвоенного ему объекта. Методы доступа к такому свойству никак не влияют на счетчик ссылок объекта. Он может удалиться, и тогда обращение к такому свойству приведет к крэшу (потому и unsafe). Сейчас используется исключительно редко;
- `weak` — позволяет свойствам с таким значением атрибута менять свое значение на nil, когда объект, на который указывала переменная, уничтожается. Очень хорошо сказывается на устойчивости работы приложения;

## Чем отличаются сильные (strong), слабые (weak) и бесхозные (unowned) ссылки на объект?
1. Сильные ссылки поддерживают объект в живых, но могут привести к нескольким нетривиальным проблемам:
- Цикл ссылок (retain cycle). Swift не собирает циклы, ссылка "R" на объект, который содержит сильную ссылку на объект "R" (возможно, косвенно), приводит к циклу ссылок.
- Не всегда возможно сделать сильные ссылки действительными сразу при создании объекта, например с делегатами.
2. Слабые ссылки решают проблему обратных ссылок. Объект может быть уничтожен, если на него указывают слабые ссылки. Слабая ссылка возвращает nil, когда объект, на который она указывает, больше не жива.
3. Бесхозные ссылки - это разные виды слабых ссылок, предназначенные для инвариантов жесткой достоверности. Необнуляемые ссылки не обнуляются. При попытке прочитать несуществующий объект по неизвестной ссылке программа выйдет из строя с ошибкой утверждения. Они полезны для отслеживания и исправления ошибок согласованности.

### Какие методы увеличивают счетчик удержания ARC на 1 (strong reference)?
- alloc / init: создает объект и заявляет права собственности на него
- retain: используется для утверждения права собственности на этот объект
- copy: Копирует объект и заявляет о праве собственности на него

### Какие методы используются для уменьшения счетчика удержаний ARC на 1?
- release: Отказаться от права собственности на объект.
- autorelease: Отказаться о праве собственности на объект.

## Жизненный цикл объекта в Swift
Объекты Swift имеют собственный жизненный цикл.
1. `Активный (live)`. Объект жив, его счетчики ссылок инициализируются на 1 сильный, 1 безымянный и 1 слабый (боковая таблица начинается с +1). Сильный и незарегистрированный доступ к ссылкам работает нормально. При наличии слабой ссылки на объект создается боковая таблица. Слабый ориентир указывает на побочную таблицу вместо объекта.
2. `Деиницирования (deiniting)`. Из активного состояния объект переходит в это состояние, когда счетчик сильных ссылок достигает нуля. Это состояние означает, что `deinit()` еще не выполнился, но сильные ссылки не действуют. Из этого состояния объект может пройти по двум маршрутам:
- Если отсутствуют слабые и бесхозные ссылки, то объект переходит в `мертвое (dead)` состояние и сразу удаляется из памяти.
- В противном случае объект переходит в `деинициализированное (deinit)` состояние.
3. `Деинитированный (deinit)`. В этом состоянии функция `deinit()` выполнена и у объекта не может быть сильных и бесхозных ссылок. Бесхозные ссылки выдают ошибку утверждения триггера. Из этого состояния объект может идти двумя маршрутами:
- В случае отсутствия слабых ссылок объект может быть немедленно освобожден. Он переходит в `мертвое (dead)` состояние.
- В противном случае необходимо удалить побочную таблицу и объект перейдет в `освобожденное (freed)` состояние.
4. `Освобожденный (freed)`. В этом состоянии объект полностью освобожден, но его вспомогательная таблица все еще жива. На этом этапе счетчик слабых ссылок достигает нуля, и побочная таблица уничтожается. Объект переходит в `мертвое (dead)` состояние.
5. `Мертвое (dead)`. В этом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на объект освобождается из кучи, не оставляя следов объекта в памяти.

### Что такое побочные таблицы (side tables)?
Это механизм для реализации слабых ссылок Swift. Обычно у объектов нет слабых ссылок, поэтому резервировать место для подсчета слабых ссылок в каждом объекте нецелесообразно. Эта информация хранится извне в дополнительных таблицах, поэтому ее можно использовать только тогда, когда это действительно необходимо.

Вместо того, чтобы прямо указывать на объект, слабые ориентиры указывают на побочную таблицу, которая, в свою очередь, указывает на объект. Это решает две проблемы:
- экономит память для слабого счетчика ссылок, пока объект действительно не понадобится;
- позволяет безопасно обнулить слабую ссылку, поскольку она не указывает напрямую на объект и больше не является предметом условий гонки.

### Что такое сильный ссылочный цикл (retain cycle)? Наведите примеры и решения этой проблемы.
Это структура памяти, в которой сильные ссылки объектов указывают друг на друга и память не может быть освобождена. Это происходит потому, что ссылка на каждый объект потеряна, но счетчик ссылок все еще существует.

Приведем простой пример. У нас есть пользователь, у которого может быть автомобиль и автомобиль у которого должен быть пользователь. Мы создаем пользователя `User(name: "Иван")` и далее создаем автомобиль `Car(model: "Audi", owner: user!)`, владельцем которого является наш пользователь. Все создалось хорошо: пользователь и автомобиль иницализированы. Но после того как мы освободили наши переменные, то не `deinit` не отработал. Мы получили сильный ссылочный цикл, который привел к утечке памяти.
```swift
class User {
  let name: String
  var car: Car?

  init(name: String) {
    self.name = name
    print("Пользователь `\(name)` инициализирован")
  }

  deinit {
    print("Пользователь `\(self.name)` деинициализирован")
  }
}

class Car {
  let model: String
  var owner: User?

  init(model: String, owner: User?) {
    self.model = model
    self.owner = owner
    print("Автомобиль `\(model)` инициализирован")
  }

  deinit {
    print("Автомобиль `\(self.model)` деинициализирован")
  }
}

var user: User? = User(name: "Иван") // Пользователь `Иван` инициализирован
var car: Car? = Car(model: "Audi", owner: user) // Автомобиль `Иван` инициализирован
user?.car = car
user = nil
car = nil
```

Чтобы избавится от этого нам нужно нужно убрать сильную ссылку у одного из свойств класса и сделать ее слабой или бесхозной. К примеру исправим класс `Car`:
```swift
class Car {
  let model: String
  weak var owner: User?

  init(model: String, owner: User?) {
    ...
  }
...
}
```

Запускаем и получаем правильный результат
```swift
user = nil // Пользователь `Иван` деинициализирован
car = nil // Автомобиль `Audi` деинициализирован
```

### Что такое утечка памяти (memory leak)?
Память, которая больше не нужна (не используется), но ее нельзя освободить. Когда объект хранится в памяти, но не может быть доступен для работающего кода.

Например у нас есть ленивое свойство замыкание, которое обращается к экземпляру и при его использование мы получаем утечку памяти:
```swift
class User {
  let firstName: String
  let secondName: String?

  lazy var fullName: () -> String = {
    if let secondName = self.secondName {
      return "\(self.firstName) \(secondName)"
    } else {
      return self.firstName
    }
  }
    
  init(firstName: String, secondName: String?) {
    self.firstName = firstName
    self.secondName = secondName
    print("Пользователь (имя: `\(firstName)`, фамилия: `\(secondName ?? "nil")`) инициализирован")
  }

  deinit {
    print("Пользователь (имя: `\(firstName)`, фамилия: `\(secondName ?? "nil")`) деинициализирован")
  }
}

var user: User? = User(firstName: "Иван", secondName: "Иванов") // Пользователь (имя: `Иван`, фамилия: `Иванов`) инициализирован
var closure = user?.fullName
closure = nil
user = nil
```

Чтобы решить эту проблему достаточно дописать в замыкании `unowned self`
```
lazy var fullName: () -> String = { [unowned self] in
  ...
}

...

user = nil // Пользователь (имя: `Иван`, фамилия: `Иванов`) деинициализирован
```

### Что такое NSZombie?
Это средство отладки памяти. В частности, когда вы устанавливаете NSZombieEnabled, тогда всякий раз, когда объект достигает счетчика сохранения 0, вместо того, чтобы быть освобожденным, он трансформируется в экземпляр NSZombie. Каждый раз, когда такой зомби получает сообщение, он регистрирует предупреждение, а не дает сбой или ведет себя непредсказуемым образом. Таким образом, вы можете отлаживать тонкие проблемы с чрезмерным выпуском / автоматическим выпуском без дополнительных инструментов или кропотливой иглы в поисках стога сена.

Когда ваше приложение вылетает из-за «BAD ACCESS», у вас проблемы - ошибка памяти, когда вы пытались вызвать метод для уже удаленного объекта. В инструментах есть поддержка NSZombie - функции, которая упрощает поиск источника ошибки, показывая вам полную историю каждого выделения, сохранения, выпуска и автоматического освобождения объекта, вызвавшего сбой!

Название является довольно очевидной игрой на том факте, что объекты обычно считаются «мертвыми», когда они достигают сохраненного счетчика 0. С этой настройкой они продолжают существовать в странном периоде полураспада - ни живые, ни совсем мертвые. Очень похоже на настоящих зомби, за исключением того, что они едят гораздо меньше мозгов.
