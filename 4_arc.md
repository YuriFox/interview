# Управление памятью (memory management)

## Как работает управление памятью в Swift?
В Swift управление памяти осуществляется при помощи автоматического подсчета ссылок (automatic reference counting), который называется ARC. Он выполняет большую часть работы по управлению памятью:
- отслеживает экземпляры класса, на которые в настоящее время ссылаются (счетчик ссылок)
- освобождает пространство памяти, используемое экземплярами, на которые больше нет сильных ссылок.
- выделяет память при инициализации или деинициализации классов.

### Какой принцип работы ARC? Приведите пример.
По умолчанию каждая ссылка, указывающая на экземпляр класса, является так называемой сильной ссылкой. Пока есть хотя бы одна сильная ссылка, указывающая на экземпляр, этот экземпляр не будет освобожден. Когда не останется сильной ссылки, указывающей на этот экземпляр, экземпляр будет освобожден.
```swift
class User: NSObject {
    let name: String
    
    init(name: String) {
        self.name = name
        print("Пользователь `\(name)` инициализирован")
    }
    
    deinit {
        print("Пользователь `\(self.name)` деинициализирован")
    }
}

var user: User? = User(name: "Иван") // Пользователь `Иван` инициализирован
var userReference_1: User? = user
user = nil
userReference_1 = nil // Пользователь `Иван` деинициализирован так как все сильные ссылки на этот объект удалены
```

## Какие виды атрибутов владения свойст вы знаете?
- `retain` / `strong` — показывает, что в сгенерированном сеттере, счетчик ссылок на присваиваемый объект будет увеличен, а у объекта, на который свойство ссылалось до этого, — счетчик ссылок будет уменьшен. При включенном ARC используется strong, а при MRC используется retain. В Swift атрибут по умолчанию;
- `copy` — означает, что мы копируем значение объекта при его создании. Также показывает, что полученное значение свойства будет иммутабельным, попытка изменения приведёт к крэшу;
- `assign` — просто присвоение адреса. С выключенным ARC является дефолтным значением в Objective-C. Стоит применять к свойствам типов, не попадающих под действие ARC (примитивные типы, тип значение);
- `unsafe_unretained` — свойство с таким типом владения просто сохраняет адрес присвоенного ему объекта. Методы доступа к такому свойству никак не влияют на счетчик ссылок объекта. Он может удалиться, и тогда обращение к такому свойству приведет к крэшу (потому и unsafe). Сейчас используется исключительно редко;
- `weak` — позволяет свойствам с таким значением атрибута менять свое значение на nil, когда объект, на который указывала переменная, уничтожается. Очень хорошо сказывается на устойчивости работы приложения;

### Чем отличаются сильные (strong), слабые (weak) и бесхозные (unowned) ссылки на объект?
1. Сильные ссылки поддерживают объект в живых, но могут привести к нескольким нетривиальным проблемам:
- Цикл ссылок (retain cycle). Swift не собирает циклы, ссылка "R" на объект, который содержит сильную ссылку на объект "R" (возможно, косвенно), приводит к циклу ссылок.
- Не всегда возможно сделать сильные ссылки действительными сразу при создании объекта, например с делегатами.
2. Слабые ссылки решают проблему обратных ссылок. Объект может быть уничтожен, если на него указывают слабые ссылки. Слабая ссылка возвращает nil, когда объект, на который она указывает, больше не жива.
3. Бесхозные ссылки - это разные виды слабых ссылок, предназначенные для инвариантов жесткой достоверности. Необнуляемые ссылки не обнуляются. При попытке прочитать несуществующий объект по неизвестной ссылке программа выйдет из строя с ошибкой утверждения. Они полезны для отслеживания и исправления ошибок согласованности.

### Какие методы увеличивают счетчик удержания ARC на 1 (strong reference)?
- alloc / init: создает объект и заявляет права собственности на него
- retain: используется для утверждения права собственности на этот объект
- copy: Копирует объект и заявляет о праве собственности на него

### Какие методы используются для уменьшения счетчика удержаний ARC на 1?
- release: Отказаться от права собственности на объект.
- autorelease: Отказаться о праве собственности на объект.

## Жизненный цикл объекта в Swift
Объекты Swift имеют собственный жизненный цикл.
1. `Активный (live)`. Объект жив, его счетчики ссылок инициализируются на 1 сильный, 1 безымянный и 1 слабый (боковая таблица начинается с +1). Сильный и незарегистрированный доступ к ссылкам работает нормально. При наличии слабой ссылки на объект создается боковая таблица. Слабый ориентир указывает на побочную таблицу вместо объекта.
2. `Деиницирования (deiniting)`. Из активного состояния объект переходит в это состояние, когда счетчик сильных ссылок достигает нуля. Это состояние означает, что `deinit()` еще не выполнился, но сильные ссылки не действуют. Из этого состояния объект может пройти по двум маршрутам:
- Если отсутствуют слабые и бесхозные ссылки, то объект переходит в `мертвое (dead)` состояние и сразу удаляется из памяти.
- В противном случае объект переходит в `деинициализированное (deinit)` состояние.
3. `Деинитированный (deinit)`. В этом состоянии функция `deinit()` выполнена и у объекта не может быть сильных и бесхозных ссылок. Бесхозные ссылки выдают ошибку утверждения триггера. Из этого состояния объект может идти двумя маршрутами:
- В случае отсутствия слабых ссылок объект может быть немедленно освобожден. Он переходит в `мертвое (dead)` состояние.
- В противном случае необходимо удалить побочную таблицу и объект перейдет в `освобожденное (freed)` состояние.
4. `Освобожденный (freed)`. В этом состоянии объект полностью освобожден, но его вспомогательная таблица все еще жива. На этом этапе счетчик слабых ссылок достигает нуля, и побочная таблица уничтожается. Объект переходит в `мертвое (dead)` состояние.
5. `Мертвое (dead)`. В этом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на объект освобождается из кучи, не оставляя следов объекта в памяти.

### Что такое побочные таблицы (side tables)?
Это механизм для реализации слабых ссылок Swift. Обычно у объектов нет слабых ссылок, поэтому резервировать место для подсчета слабых ссылок в каждом объекте нецелесообразно. Эта информация хранится извне в дополнительных таблицах, поэтому ее можно использовать только тогда, когда это действительно необходимо.

Вместо того, чтобы прямо указывать на объект, слабые ориентиры указывают на побочную таблицу, которая, в свою очередь, указывает на объект. Это решает две проблемы:
- экономит память для слабого счетчика ссылок, пока объект действительно не понадобится;
- позволяет безопасно обнулить слабую ссылку, поскольку она не указывает напрямую на объект и больше не является предметом условий гонки.





Что такое @property?
?

Что такое @synthesize?
@synthesize генерирует методы getter и setter для вашего свойства.

Почему @property / @synthesize не существует в Swift?
Swift не делает различий между свойствами и переменными экземпляра (т.е. базовым хранилищем для свойства). Чтобы определить свойство, вы просто объявляете переменную в контексте класса.
Если у вас есть опыт работы с Objective-C, вы можете знать, что он предоставляет два способа хранения значений и ссылок как части экземпляра класса. Помимо свойств, вы можете использовать переменные экземпляра в качестве резервного хранилища для значений, хранящихся в свойстве.
Swift объединяет эти концепции в одно объявление свойства. Свойство Swift не имеет соответствующей переменной экземпляра, и доступ к резервному хранилищу для свойства напрямую не осуществляется. Такой подход позволяет избежать путаницы в том, как получить доступ к значению в разных контекстах, и упрощает объявление свойства до единого окончательного утверждения. Вся информация о свойстве, включая его имя, тип и характеристики управления памятью, определяется в одном месте как часть определения типа.


Что такое @dynamic?
Он сообщает компилятору, что геттер и сеттеры реализованы где-то еще (например, в подклассе).

Что такое атомарность (atomicity)? В чем разница атомарный (atomic) и не атомарный (nonatomic)?
Атомарные свойства обеспечивают надежный доступ к ним в многопоточной среде - то есть значение, возвращаемое из геттера или устанавливаемое через сеттер, всегда полностью извлекается или устанавливается независимо от того, какие другие потоки выполняются одновременно. Значительно медленнее. В Objective-C устанавливается по умолчанию.
Не атомарные свойства быстрее, но не потокобезопасны. Что может привести к неожиданному поведению, когда два разных процесса одновременно обращаются к одной и той же переменной
В Swift по умолчанию используется nonatomic и отсутствует atomic.

Что такое утечка памяти (memory leak)?
Память, которая больше не нужна, но ее нельзя освободить. Когда объект хранится в памяти, но не может быть доступен для работающего кода.

Можно ли отследить за утечкой памяти?

Что такое Garbage Collector?
???

Что такое сильного ссылочного цикла (retain cycle)?
Retain cycle - это структура памяти, в которой сильные ссылки объектов указывают друг на друга и память не может быть освобождена. Это происходит потому, что ссылка на каждый объект потеряна, но счетчик ссылок все еще существует.


Написать код для создания сильного ссылочного цикла (retain cycle)? (Взять из документа)
