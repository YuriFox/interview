# Объектно ориентированное программирование

## Что такое инкапсуляция? Приведите пример
Объединение свойств и методов в общую модель, которая скрывает детали. Например создадим `NetworkService`, который при помощи `URLSession` отправляет запросы. Из вне нас не интересует `session`, но интересует открытый метод `sendUrlRequest(_:)`
```swift
class NetworkService {
  private let session: URLSession

  init(session: URLSession = .shared) {
    self.session = session
  }

  func sendUrlRequest(_ urlRequest: URLRequest) {
    ...
  }
}
```

### За счет чего достигается инкапсуляция в Swift? Какие уровни доступа вы знаете? Какая разница между ними?
В Swift инкапсуляция достигается за счет использования следующих пяти ключевых слов управления доступом: private, fileprivate, internal, public и open.
Эти уровни доступа либо ограничивают, либо открывают доступ в пределах файла или модуля. Давайте посмотрим на каждый из них, от наиболее строгих и частных до наименее ограничительных и открытых:
1. `private` - является наиболее ограничительным. Если вы определяете что-то как `private`, это означает, что оно является частным для этой области объявления и не может быть доступно извне.
2. `fileprivate` - является вторым по значимости ограничением. Определение чего-либо как fileprivate означает, что оно будет доступно только в пределах того файла, в котором оно было объявлено.
3. `internal` - уровень доступа по умолчанию, который будет установлен, если вы явно не укажете иное. Internal означает, что эту вещь можно использовать в любом месте модуля, в котором она была определена. Обычно, если вы создаете приложение, internal означает, что оно будет доступно в любом месте этого приложения. Если вы создаете библиотеку / фреймворк, внутренний означает, что он будет доступен в этой библиотеке / фреймворке, но не вне приложения, которое использует библиотеку.
4. `public` - означает, что к чему-то можно получить доступ не только в определяющем файле и модуле, но и из внешнего модуля, который импортирует тот, в котором это было определено. Фактически, public объявляет публичный интерфейс для модуля.
5. `open` - означает, что что-то является общедоступным и может быть разделено на подклассы не только внутри модуля, в котором оно было определено, но и любым, кто его импортирует.

## Что такое полиморфизм?
Полиморфизм в Swift бывает двух видов: Полиморфизм во время компиляции и полиморфизм во время выполнения
1. Полиморфизм во время компиляции -  это перегрузка метода (method overloading). При перегрузке метода функция может выполнять разные действия с одним и тем же именем функции, но должна иметь другую сигнатуру (название метода, количество параметров, тип данных и/или порядок параметров). В частности, перегрузка инициализатора позволяет нам инициализировать объект по-разному. Для примера возмем инициализаторы `NSNumber`, все они имеют одинаковое название параметров `init(value:)`, но разный тип `Int8`, `Float`, `Double`...
```swift
open class NSNumber : NSValue {    
  public init(value: Int8)
  public init(value: Int16)
  public init(value: Int32)
  public init(value: Int64)
  public init(value: Float)
  public init(value: Double)
  public init(value: Bool)
}
```
2. Полиморфизм во время выполнения - это переопределение метода (method overriding). Swift вызывает фактический метод во время выполнения программы, но он не будет знать, какой метод вызывать во время компиляции. Это концепция, при которой, хотя имя метода и переданные параметры аналогичны, поведение различается в зависимости от типа объекта. Например создадим несколько классов, которые наследуют друг друга и переопределим метод `description()`. Когда мы вызовим этот метод для каждого экземпляра класса мы получим разные результаты:
```swift
class Person {
    let name: String
             
    init(name: String) {
        self.name = name
    }
    
    func description() {
        print("Имя: \(self.name)")
    }
}
         
class Employee: Person {
    var company: String
    
    init(name: String, company: String) {
        self.company = company
        super.init(name:name)
    }
    
    override func description() {
        print("Имя: \(self.name), Сотрудник компании: \(self.company)")
    }
}
         
class Developer: Employee {
    
    override func description() {
        print("Имя: \(self.name), Разработчик компании: \(self.company)")
    }
    
}

let persons: [Person] = [
    Person(name:"Тарас"),
    Employee(name: "Андрей", company: "Microsoft"),
    Developer(name: "Юрий", company: "Apple")
]

persons.forEach { $0.description() }
// Имя: Тарас
// Имя: Андрей, Сотрудник компании: Microsoft
// Имя: Юрий, Разработчик компании: Apple
```

## Наследование
Это процесс, посредством которого один объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Польза наследования в том, что оно дополняет идею абстракции. Абстракция позволяет представить объекты с разным уровнем детальности. Наследование упрощает программирование, позволяя создать универсальные методы для выполнения всего, что основано на общих свойствах, и затем написать специфические методы для выполнения специфических операций над конкретными типами данных.

### Какие есть модификаторы инициализации класса? 
1. `convenience` - Вспомогательный инициализатор для вызова назначенного инициализатора из того же класса, что и вспомогательный инициализатор, с некоторыми из параметров назначенного инициализатора, установленными на значения по умолчанию. Всегда использует `self.init(...)` и не может быть наследован. Возмем к примеру `UIAlertController`:
```swift
convenience init(title: String?, message: String?, preferredStyle: UIAlertController.Style)
```
2. `required` - модификатор перед определением инициализатора класса, чтобы указать, что каждый подкласс класса должен реализовывать этот инициализатор. Подставляется автоматически для всех классов, который наследуют протокол с инициализацией. Например `UIView`, который использует `NSCoding` протол.
```swift
required init?(coder: NSCoder)
```

## Что такое интерфейс? 
Это абстрактный класс, который не реализует ни одно свойство или метод. В Swift вместо интерфейсов используются протоколы.

### Как создать интерфейс в Swift?
В Swift нет абстрактных классов (как и в Objective-C). Лучше всего будет использовать протокол, который похож на интерфейс Java. В Swift 2.0 вы можете затем добавлять реализации методов и реализации вычисляемых свойств с использованием расширений протокола. Единственные ваши ограничения заключаются в том, что вы не можете указывать переменные или константы (variables or constants) и не использовать динамическую отправку (no dynamic dispatch).

## Что такое абстрактный класс?
Это базовый класс, который не предполагает создания экземпляров.

### Как создать абстрактный класс в Swift?
Вы так же можете использовать обычный класс для этих целей.

## В чем между типом значений и ссылочным типом? Наведите примеры.
Основное различие между типом значения и ссылочным типом заключается в том, что тип значения копирует данные, в то время как ссылочные типы совместно используют одну копию своих данных. Тип значения неизменяемый - это означает, что когда мы создаем экземпляр с типом значения, он создает уникальную копию данных и не может измениться но ссылочный тип является изменяемым, его значение может быть изменено.
Рассмотрим пример типа значаний на основе структуры `User`
```swift
struct User {
    var name: String
}
var user_0 = User(name: "Ivan")
var user_1 = user_0
user_1.name = "Taras"
print(user_0.name) // Ivan
print(user_1.name) // Taras
```
Рассмотрим тот же самый пример, только ссылочного типа на основе класса `User`
```swift
class User {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

var user_0 = User(name: "Ivan")
var user_1 = user_0
user_1.name = "Taras"
print(user_0.name) // Taras
print(user_1.name) // Taras
```

### Какие типы относятся к типу значений, а какие относятся к ссылочному типу в Swift?
К типу значений относятся:
- Примитивные типы: Int, Float, Double, String и подобные. Не путать с NSNumber, NSString и другими, так как они относятся к ссылочному типу
- Коллекции: Array, Set, Dictionary. Не путать с NSArray, NSSet, NSDictionary, так как они относятся к ссылочному типу
- Tuple, Enum, Struct

К ссылочному типу относятся:
- Class
- Closure
- Function

### В чем разница между Struct и Class?
Структура - это тип значений, а класс - это ссылочный тип. У классов есть дополнительные возможности, которых нет у структур:
- Наследование. Позволяет одному классу наследовать характеристики другого и дополнять их.
- Деинициализаторы позволяют экземпляру класса освобождать любые ресурсы, которые он назначил.
- Подсчет ссылок позволяет использовать более одной ссылки на экземпляр класса.

### Что лучше использовать класс или структуру? Наведите примеры.
Класс нужно использовать в слудующих случаях:
- Когда нету смысла копировать один и тот же объект. Например у нас есть модель пользователя, которая передается между экранами. Лучше использовать одну ссылку и передавать ее, чем копировать каждый раз.
- Когда объект привязак к событиям из извне. Например какой-то менеджер или сервис, к которому извне могут обращатся различные классы.
- Когда свойства объекта перезаписывающие. Напримеру у нас есть пользователь, данные которого могут быть изменены и перезаписаны.
- Когда фреймворк требует наследования. Таких ситуаций очень много, например: самая простая это объект CoreData (NSManagedObject) или Realm (Object), мы не можем использовать структуру, так как обязаны наследовать эти классы. Другой пример - это `UIView` и аналогичная ситуация.

Во всех остальных случаях лучше использовать структуру.

## Назовите типа структуры данных для распределения памяти. Какая между ними разница?
Существует два типа:
1. Stack (Стэк) - это простая структура памяти FIFO (first-in-first-out). Stack всегда используется для хранения следующих двух вещей:
- Ссылочной части локальных переменных и параметров ссылочного типа
- Локальных переменных и параметров метода с типом значения.

2. Heap (Куча) - это структура памяти, в которой хранятся случайные объекты без выстраивания. Преимущество состоит в том, что он позволяет выделять или освобождать объекты в случайном порядке. Однако это потребует от вас использования функций сборщика мусора для освобождения памяти.
В динамической памяти хранится следующее: содержимое объектов ссылочного типа.
